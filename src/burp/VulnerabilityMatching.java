package burp;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import java.util.ArrayList;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;


public class VulnerabilityMatching {
			
	HashMap<String, List<String>> vulnerabilityFeaturesDict = new HashMap<String, List<String>>();
	// 被匹配出来的漏洞URL存储字典
	KeywordsOfVulnerability featuresdata = new KeywordsOfVulnerability();
	// 初始化读取的相关漏洞json数据
		
	public  ArrayList<String> vulnerabilityMatchingUrl(String url) {
		/**
		 * 接受url参数，若url中存在漏洞关键词则返回漏洞名称和漏洞关键词，反之返回空列表
		 */
		ArrayList<String> callbackdata = new ArrayList<String>();
		Set<String> Ar1 = featuresdata.getPocUrlMap().keySet();
		for(String key : Ar1) {
			String keyre = ".*"+key+".*";
			if(url.matches(keyre)) {
				String zhi = featuresdata.getPocUrlMap().get(key);
				callbackdata.add(key);
				callbackdata.add(zhi);
			}
		}
		return callbackdata;
	}
	
	public  ArrayList<String> vulnerabilityMatchingCookie(String cookie) {
		/**
		 * 接受HTTP数据包中cookie的值，判断是否存在漏洞特征，若存在返回漏洞名称和漏洞关键词，反之返回空列表
		 */
		ArrayList<String> callbackdata = new ArrayList<String>();
		for(String key : featuresdata.getPocCookieMap().keySet()) {
			String keyre = ".*"+key+".*";
			if(cookie.matches(keyre)) {
				String zhi = featuresdata.getPocCookieMap().get(key);
				callbackdata.add(key);
				callbackdata.add(zhi);
			}
		}
		return callbackdata;
	}

	public boolean isVulnerabilityFeatures(String Vurl) {
		/**
		 * 判断参数URL是否在漏洞存储字典中，若存在返回true，不存在返回false
		 */
		boolean isresult = vulnerabilityFeaturesDict.containsKey(Vurl);
		return isresult;
	}
	
	public boolean isVulnerabilityFeatures(String Vurl,String vname) {
		/**
		 * 判断url和漏洞名称是否存在漏洞存储字典中，若存在返回true，反之返回false
		 */
		if(vulnerabilityFeaturesDict.containsKey(Vurl)) {
			ArrayList<String> forvname = this.forVulnerabilityFeatures(Vurl);
			if(forvname.contains(vname)) {
				return true;
			}
		}else {
			return false;
		}
		return false;
	}
	
	private void setVulnerabilityFeatures(String Vurl,List<String> Vname) {
		/**
		 * 往漏洞存储字典中添加存在漏洞url和具体的漏洞名称（不对外开放函数）
		 */
		this.vulnerabilityFeaturesDict.put(Vurl, Vname);
	}
	
	private ArrayList<String> forVulnerabilityFeatures(String Vurl) {
		/**
		 * 对漏洞存储字典中的值的列表进行遍历出来，返回列表形式
		 */
		HashMap<String, List<String>> vdict = this.vulnerabilityFeaturesDict;
		ArrayList<String> rdict = new ArrayList<String>();
		for(String vul:vdict.get(Vurl)) {
			rdict.add(vul);
		}
		return rdict;
	}
	
	public void addVulnerabilityFeatures(String vurl,String vname) {
		/**
		 * 往漏洞存储字典中添加漏洞url和漏洞名称
		 */
		if(this.isVulnerabilityFeatures(vurl)) {
			ArrayList<String> forvname = this.forVulnerabilityFeatures(vurl);
			if(!forvname.contains(vname)) {
				this.vulnerabilityFeaturesDict.get(vurl).add(vname);
			}
		}else {
			List<String> initvname = new ArrayList<String>();
			initvname.add(vname);
			this.setVulnerabilityFeatures(vurl, initvname);
		}
	}
	
}


class KeywordsOfVulnerability{
	
	private HashMap<String,String> POC_URL_MAP = new HashMap<String, String>();
	private HashMap<String, String> POC_COOKIE_MAP = new HashMap<String, String>();
	
	private static String readJsonFile() {
		/**
		 * 以文本形式读取json内容
		 */
		String jsonStr = "";
		try {
		    File directory = new File("");
		    File filePath = directory.getAbsoluteFile();
		    String filePath1 = filePath + "/KeywordsOfVulnerability.json";
		    FileReader fileReader = new FileReader(filePath1);
		    Reader reader = new InputStreamReader(new FileInputStream(filePath1),"utf-8");
		    int ch = 0;
		    StringBuffer sb = new StringBuffer();
		    while ((ch = reader.read()) != -1) {
		    	sb.append((char) ch);
		    }
		    fileReader.close();
		    reader.close();
		    jsonStr = sb.toString();
		    return jsonStr;
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
	}
	
    private  void jsonSort() {
    	/**
    	 * 解释获取到的json数据
    	 */
        JSONObject jobj = JSON.parseObject(readJsonFile());
        
        for(String key:jobj.keySet()) {
        	if("POC_URL".equals(key)) {
        		JSONArray student =jobj.getJSONArray(key);
                for(int i=0;i<student.size();i++) {
                	JSONObject Br1 = student.getJSONObject(i);
                    for(String emty:Br1.keySet()) {
                    	POC_URL_MAP.put(emty,Br1.getString(emty));
                    }
                }  
        	}else if("POC_COOKIE".equals(key)) {
        		JSONArray student =jobj.getJSONArray(key);
                for(int i=0;i<student.size();i++) {
                	JSONObject Br1 = student.getJSONObject(i);
                    for(String emty:Br1.keySet()) {
                    	POC_COOKIE_MAP.put(emty,Br1.getString(emty));
                    }
                }	
        	}	

        }
    } 

    public HashMap<String, String> getPocUrlMap() {
    	this.jsonSort();
    	return POC_URL_MAP;
    }
    
    public HashMap<String, String> getPocCookieMap() {
    	this.jsonSort();
    	return POC_COOKIE_MAP;
    }
}




